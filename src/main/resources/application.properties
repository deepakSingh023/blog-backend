spring.application.name=blog-backend


cloudinary.cloud-name =${CLOUDINARY_NAME}

cloudinary.api-key =${CLOUDINARY_API_NAME}

cloudinary.api-secret =${CLOUDINARY_API_SECRET}

jwt-secret =${JWT_SECRET}
spring.data.mongodb.uri=${MONGO_URI}


# PostgreSQL connection
spring.datasource.url=${POSTGRES_URI}

spring.datasource.username=${POSTGRES_NAME}
spring.datasource.password=${POSTGRES_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.datasource.hikari.maximum-pool-size=5
spring.datasource.hikari.minimum-idle=1
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# Hibernate / JPA
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect


spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=50MB
spring.servlet.multipart.max-request-size=50MB
# This is the most important line for 500 errors with no logs:
spring.servlet.multipart.resolve-lazily=true


spring.servlet.multipart.location=/tmp

logging.level.root=INFO
logging.level.com.example.blog_backend=INFO
logging.level.org.springframework=INFO

management.endpoint.health.show-details=always
management.datadog.metrics.export.enabled=true
management.defaults.metrics.export.enabled=true

management.metrics.use-global-registry=true
management.endpoint.metrics.enabled=true

management.endpoint.web.base-path=/actuator

management.endpoints.web.exposure.include=*
